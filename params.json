{"name":"Nanotwitter","tagline":"","body":"NanoTwitter TEAMAB\r\n=======\r\nTeam member: Jiancheng Zhu, Alex Suk, Ben Winschel, Ethan Stein  \r\nDec 8, 2015\r\n\r\n[ ![Codeship Status for teamab2015/NanoTwitter](https://codeship.com/projects/c4bba410-7f91-0133-3c3e-62195a4c75a1/status?branch=master)](https://codeship.com/projects/120618)\r\n\r\n[![Code Climate](https://codeclimate.com/github/cheng9393/NanoTwitter/badges/gpa.svg)](https://codeclimate.com/github/cheng9393/NanoTwitter)\r\n\r\n[Profile http://teamab2015.github.io/NanoTwitter](http://teamab2015.github.io/NanoTwitter \"Profile\")  \r\n\r\n[Github https://github.com/teamab2015/NanoTwitter](https://github.com/teamab2015/NanoTwitter)\r\n\r\n[Demo https://teamab.herokuapp.com](https://teamab.herokuapp.com \"Demo\")  \r\n\r\nThis a sinatra application that imitates Twitter. It has following functions:  \r\n* view timeline\r\n* follow/unfollow\r\n* notification\r\n* tweet with _@ mention_ and _# tag_\r\n* tag view\r\n* reply view  \r\n\r\n![ScreenShot](http://teamab2015.github.io/NanoTwitter/images/Screen%20Shot%202015-12-07%20at%203.30.28%20AM.png)\r\n![Screenshot](http://teamab2015.github.io/NanoTwitter/images/test.png)\r\n\r\nTechnology Description\r\n------\r\nRedis & resque-pool\r\n\r\nNanoTwitter cached all the relationship (\"followers-#{followee_id}\" stores a set of follower_ids), all users (\"user-#{user.id}\" stores a JSON string of user info), timeline (\"homeTimeline\" stores the global timeline, \"userTimeline-#{user_id}\" stores the timeline of a user). The relationship and user cache is loaded at the start of NanoTwitter and updated while any action among follow, unfollow, register happens.The timeline is a first fetched from database and then loaded into redis. When a person tweet, unprocessed tweet string will be added to related timeline list. Since the all timeline cache has an expire timeout of one of two minutes, processed tweet string will show up after that expire timeout. NanoTwitter also use queue to process tweet, because tweet is very costly, as it involves write tag, mention to database, add tag and mention link to original tweet and then write it to database.\r\n\r\nResult of loader.io test\r\n------\r\n\r\n| Object & Condition (maintain client load 250) | Average \t| Min \t| Max   \t| Success \t| Timeout \t|\r\n|---------------------------------------------\t|---------\t|-----\t|-------\t|---------\t|---------\t|\r\n| testuser tweet u = 100, t = 500, f = 30     \t| 1437    \t| 24  \t| 4333  \t| 5054    \t| 0       \t|\r\n| testuser home u = 100, t = 500, f = 30      \t| 2940    \t| 38  \t| 9110  \t| 2326    \t| 0       \t|\r\n| home u = 100, t = 500, f = 30               \t| 1537    \t| 18  \t| 4105  \t| 4685    \t| 0       \t|\r\n| testuser tweet u = 500, t = 500, f = 100    \t| 1215    \t| 19  \t| 3410  \t| 5996    \t| 0       \t|\r\n| testuser home u = 500, t = 500, f = 100     \t| 1522    \t| 42  \t| 4623  \t| 4729    \t| 0       \t|\r\n| home u = 500, t = 500, f = 100              \t| 1053    \t| 18  \t| 3266  \t| 6815    \t| 0       \t|\r\n| testuser tweet u = 3000, t = 2000, f = 1000 \t| 4571    \t| 81  \t| 10004 \t| 1346    \t| 52      \t|\r\n| testuser home u = 3000, t = 2000, f = 1000  \t| 1584    \t| 27  \t| 4032  \t| 4585    \t| 0       \t|\r\n| home u = 3000, t = 2000, f = 1000           \t| 1226    \t| 15  \t| 4039  \t| 5941    \t| 0       \t|\r\n\r\n\r\nUsage\r\n------\r\n\r\nrequire ruby 2.+  \r\nRun rake db:reset to clear the database and reseed.  \r\nThe development database comes with a user(email=test@test.com, password=test).  \r\n\r\nRoutes (not updated)\r\n------\r\n`/`  \r\nIf not logged in, then display top 50 tweets of all users, else redirect to `/user/:logged_in_user_id`\r\n\r\n`/user/:id`  \r\nThe home page of user, displaying Top 50 tweets of followed users and himself\r\n\r\n`/login/:id`  \r\nlog in the user with user_id, may accept requests with password parameter to log in\r\n\r\n`/logout`  \r\nlog out the current user, after logging out redirect to `/`\r\n\r\n`/user/register`  \r\ndisplay register page\r\n\r\n`/login`  \r\ndisplay the login page, after logging in redirect to `/user/:id`\r\n\r\n`/test/reset`  \r\ndelete all rows containing test user in relations table, delete all tweets send by test users, delete all test users\r\n\r\n`/test/seed/:n`  \r\ncreate n fake users\r\n\r\n`/test/tweets/:n`  \r\nuser “testuser” generates n new fake tweets\r\n\r\n`/test/follow/:n`  \r\nrandomly select n users to follow user “testuser”\r\n\r\n`/test/users`  \r\ndiaplay all the fake users\r\n\r\nAPI (proposed)\r\n---\r\n\r\n**GET `v1/users/:id`**  \r\nGet the user of given id   \r\nresult:\r\n```\r\n{\r\n    name: text,\r\n    email: text,\r\n    id: integer,\r\n    avatar: text\r\n}\r\n```\r\n\r\n**POST `v1/users`**  \r\nCreate a user  \r\nparameters:\r\n```\r\nname: text, email: text, id: integer, avatar: text\r\n```\r\n\r\n**GET `v1/tweets/:id`**\r\nGet the tweet of given id  \r\nresult:\r\n```\r\n{\r\n    id: integer,\r\n    content: text,\r\n    created: datetime,\r\n    sender_id: integer,\r\n    (optional)user: {\r\n        name: text,\r\n        email: text,\r\n        id: integer,\r\n        avatar: text\r\n        }\r\n}\r\n```\r\n\r\n**POST `v1/users/:id/tweets`**  \r\n*authentication: true*  \r\nCreate a tweet for a user  \r\nparameters:\r\n```\r\nid: integer, content: text\r\n```\r\n\r\n**GET `v1/tweets/?sort=[+-{field_name}]&page={#}&per_page={#}&embeded=[{field_name}]`**  \r\nSearch for tweets\r\nresult:\r\n```\r\n[{\r\n    id: integer,\r\n    content: text,\r\n    created: datetime,\r\n    sender_id: integer,\r\n    (optional)user: {\r\n        name: text,\r\n        email: text,\r\n        id: integer,\r\n        avatar: text\r\n        }\r\n}]\r\n```\r\n\r\n**GET `v1/users/:id/tweets?sort=[+-{field_name}]&page={#}&per_page={#}&embeded=[{field_name}]`**  \r\nSearch the tweets send by a user  \r\nresult:\r\n```\r\n[{\r\n    id: integer,\r\n    content: text,\r\n    created: datetime,\r\n    sender_id: integer,\r\n}]\r\n```\r\n\r\n**GET `v1/users/:id/followees?embeded=[{field_name}]`**  \r\nGet the followees of a user  \r\nresult:\r\n```\r\n[{followee_id:integer}]\r\n```\r\nor\r\n```\r\n[{name: text,\r\n    email: text,\r\n    id: integer,\r\n    avatar: text\r\n}]\r\n```\r\n\r\n**GET `v1/users/:id/followers?embeded=[{field_name}]`**  \r\nGet the followees of a user  \r\nresult:\r\n```\r\n[{follower_id:integer}]\r\n```\r\nor\r\n```\r\n[{\r\n    name: text,\r\n    email: text,\r\n    id: integer,\r\n    avatar: text\r\n}]\r\n```\r\n\r\n**POST `/users/:id/follow?followee={followee_id}`**  \r\n*authentication: true*  \r\nCreate relation that the user(with id) follows another(with followee_id)  \r\n\r\n**POST `/users/:id/unfollow?followee={followee_id}`**  \r\n*authentication: true*  \r\nDelete relation that the user(with id) follows another(with followee_id)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}